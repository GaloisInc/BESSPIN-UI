from flask import current_app, request
import json
from flask_restplus import Resource, fields
from uuid import uuid4

from . import api
from app.models import db, VulnerabilityConfigurationInput, FeatureModel
from app.api.feature_model import featureModelSwagger

"""
    Since all the routes here are for managing our Vulnerability`ConfigurationInput
    we set up a root namespace that is the prefix for all routes
    defined below
"""
ns = api.namespace(
    'vulnerability-config-input',
    description='Operations on vulnerability configuration inputs'
)

"""
    Define a swagger model that can be used for:
    - defining expected shape of inputs/outputs to the api
    - autogenerate swagger documentation for the structure of api data
"""
new_vulnconfig_input = api.model('NewVulnerabilityConfigurationInput', {
    'label': fields.String(
        required=False,
        description='optional user-defined label for this vunlerability configuration input'),
    'vulnClass': fields.String(
        required=True,
        description=f'valid vulnerability class'),
    'workflowId': fields.Integer(
        required=True,
        descrption='ID of Workflow this vulnerability class should be associated with'
    )
})

"""
    Extend the new config input with the other optional fields that can be added
"""
existing_vulnconfig_input = api.inherit(
    'ExistingVulnerabilityConfigurationInput',
    new_vulnconfig_input,
    {
        'vulnConfigId': fields.Integer(
            required=False,
            description='VulnerabilityConfigurationInputs identifier'),
        'createdAt': fields.String(
            required=False,
            description='Date vulnerability-configuration-input was initiallly created'),
        'updatedAt': fields.String(
            required=False,
            description='Date vulnerability-configuration-input was last updated'),
        'featureModel': fields.Nested(featureModelSwagger)
    }
)


@ns.route('')
class VulnerabilityConfigurationInputListApi(Resource):
    # by declaring which swagger model we use to marshal data,
    # flask will automagically convert any returned data to be
    # limited to that shape. This means that can effectively be
    # hidden by not including them in the definition
    @ns.marshal_list_with(existing_vulnconfig_input)
    def get(self):
        current_app.logger.debug(f'fetching all vulnerability configuration inputs')
        return VulnerabilityConfigurationInput.query.all()

    # we can also declare the expected shape of input data to allow
    # for flask to validate that the correct data is supplied in a POST/PUT
    @ns.marshal_with(existing_vulnconfig_input)
    @ns.expect(new_vulnconfig_input, validate=True)
    def post(self):
        vulnconfig_input = json.loads(request.data)
        feature_model = FeatureModel(
            uid=str(uuid4())
            # TODO:
            #  filename=PATH_TO_TESTGEN_CLAFER_FOR_GIVEN_VULN_CLASS,
            #  source=FM_JSON_FOR_TESTGEN_CLAFER_FOR_GIVEN_VULN_CLASS,
        )
        db.session.add(feature_model)
        db.session.commit()
        new_vulnconfig_input = VulnerabilityConfigurationInput(
            label=vulnconfig_input['label'],
            vulnClass=vulnconfig_input['vulnClass'],
            featureModelUid=feature_model.uid,
            workflowId=vulnconfig_input['workflowId']
        )
        db.session.add(new_vulnconfig_input)
        db.session.commit()

        return new_vulnconfig_input


@ns.route('/<int:vulnConfigInputId>')
class VulnerabilityConfigurationInputApi(Resource):
    @ns.doc('update a vulnerability configuration input')
    @ns.marshal_list_with(existing_vulnconfig_input)
    @ns.expect(new_vulnconfig_input, validate=True)
    def put(self, vulnConfigInputId):
        current_app.logger.debug(f'updating vulnConfigInputId: {vulnConfigInputId}')
        vulnconfig_input = json.loads(request.data)
        existing_vulnconfig_input = VulnerabilityConfigurationInput.query.get_or_404(vulnConfigInputId)
        existing_vulnconfig_input.label = vulnconfig_input['label']
        existing_vulnconfig_input.featureModelUid = vulnconfig_input['featureModelUid']

        db.session.add(existing_vulnconfig_input)
        db.session.commit()

        return existing_vulnconfig_input

    @ns.doc('fetch a vulnerability configuration input')
    @ns.marshal_with(existing_vulnconfig_input)
    def get(self, vulnConfigInputId):
        current_app.logger.debug(f'fetching vulnConfigInputId: {vulnConfigInputId}')
        return VulnerabilityConfigurationInput.query.get_or_404(vulnConfigInputId)
