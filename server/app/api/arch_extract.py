import os
import stat
import pwd
import subprocess
from shlex import quote
import tempfile

import json
import base64
from flask import current_app, request
from flask_restplus import abort, Resource, fields

from config import config
from app.models import (
    db,
    ArchExtract,
    ArchExtractOutput,
)
from app.lib.testgen_utils import (
    get_variable,
)
from app.lib.arch_extract_utils import (
    get_config_arch_extract_template
)
from . import api


ns = api.namespace(
    'arch-extract',
    description='Operations on arch extract'
)

"""
    Define a swagger model that can be used for:
    - defining expected shape of inputs/outputs to the api
    - autogenerate swagger documentation for the structure of api data
"""

arch_extract_list_elem = api.model('ArchExtractListElem', {
    'label': fields.String(
        required=False,
        description='Id of arch extract record'),
    'archExtractId': fields.Integer(
        required=True,
        description='Id of arch extract record'),
})

arch_extract_list = api.model('ArchExtractList', {
    'archExtractIdList': fields.List(fields.Nested(arch_extract_list_elem)),
})

arch_extract_new_input = api.model('ArchExtractNewInput', {
    'label': fields.String(
        required=False,
    ),
})

arch_extract_output_record = api.model('ArchExtractOutput', {
    'archExtractOutputId': fields.Integer(
        required=True,
    ),
    'archExtractOutputFilename': fields.String(
        required=True,
    ),
    'archExtractOutputContent': fields.String(
        required=False,
        description='content of the image generated by arch-extract. Not a required field'
    ),
    'archExtractOutputContentConverted': fields.String(
        required=False,
        description='content of the image generated by arch-extract. Not a required field'
    ),
})

arch_extract_record = api.model('ArchExtract', {
    'label': fields.String(
        required=False,
        description='Id of arch extract record'),
    'archExtractId': fields.Integer(
        required=True,
        description='Id of arch extract record'),
    'archExtractInput': fields.String(
        reuired=True,
        description='Text of the arch-extract config',
    ),
    'archExtractOutputList': fields.List(fields.Nested(arch_extract_output_record),
        reuired=False,
        description='arch-extract Output List',
    )
})

arch_extract_input = api.model('ArchExtractInput', {
    'archExtractInput': fields.String(
        reuired=True,
        description='Text of the arch-extract config',
    )
})

arch_extract_output_list = api.model('ArchExtractOutputList', {
    'archExtractOutputList': fields.List(fields.Nested(arch_extract_output_record)),
})


def make_arch_extract_command(cmd):
    """
    :param cmd: string of the command to run

    :return: list of parameters for subprocess to use
    """
    nix_cmd = "cd ~/tool-suite &&" + "nix-shell --run " + quote(cmd)
    return ["su", "-", "besspinuser", "-c", nix_cmd]


@ns.route('/list')
class ArchExtractListApi(Resource):
    @ns.marshal_list_with(arch_extract_list)
    def get(self):
        current_app.logger.debug(f'list all arch extract entries')
        arch_extract_all = ArchExtract.query.all()

        res = [{ 'archExtractId': e.archExtractId, 'label': e.label} for e in arch_extract_all]

        current_app.logger.debug(f'list is {str(res)}')
        return { 'archExtractIdList': res }


@ns.route('/fetch/<string:archExtractId>')
class ArchExtractFetchApi(Resource):
    @ns.marshal_list_with(arch_extract_record)
    def get(self, archExtractId):
        current_app.logger.debug(f'fetching an arch extract entry')
        existing_arch_extract = ArchExtract.query.get_or_404(int(archExtractId))

        existing_arch_extract_outputs = ArchExtractOutput.query.filter_by(archExtractId=int(archExtractId))

        return {
            'archExtractId' : existing_arch_extract.archExtractId,
            'archExtractInput': existing_arch_extract.archExtractInput,
            'archExtractOutputList': [
                { 'archExtractOutputId': r.archExtractOutputId, 'archExtractOutputFilename': r.archExtractOutputFilename}
                for r in existing_arch_extract_outputs
            ],
        }



@ns.route('/new/<string:cpu>')
class ArchExtractNewApi(Resource):
    @ns.expect(arch_extract_new_input)
    @ns.marshal_list_with(arch_extract_record)
    def post(self, cpu):
        current_app.logger.debug(f'create new arch extract entry')
        data = json.loads(request.data)
        current_app.logger.debug(f'New data: {str(data)}')

        arch_extract_config = get_config_arch_extract_template(cpu)

        new_arch_extract = ArchExtract(
            label=data['label'],
            archExtractInput=arch_extract_config,
        )
        db.session.add(new_arch_extract)
        db.session.commit()

        return new_arch_extract

@ns.route('/submit/<string:archExtractId>')
class ArchExtractSubmitApi(Resource):
    @ns.expect(arch_extract_input)
    def post(self, archExtractId):
        current_app.logger.debug(f'submit arch extract entry')
        data = json.loads(request.data)
        current_app.logger.debug(f'Submit data: {str(data)}')

        existing_arch_extract = ArchExtract.query.get_or_404(int(archExtractId))

        existing_arch_extract.archExtractInput = data['archExtractInput']
        db.session.add(existing_arch_extract)
        db.session.commit()

        return

@ns.route('/run/<string:archExtractId>')
class ArchExtractRunApi(Resource):
    @ns.marshal_list_with(arch_extract_output_list)
    def post(self, archExtractId):
        current_app.logger.debug(f'run arch extract entry')

        if config['default'].USE_TOOLSUITE:
            if os.environ.get('BESSPIN_CONFIGURATOR_USE_TEMP_DIR'):
                WORK_DIR_OBJ = tempfile.TemporaryDirectory()
                WORK_DIR = WORK_DIR_OBJ.name
            else:
                WORK_DIR = tempfile.gettempdir()

            arch_extract_config_file_path = os.path.join(WORK_DIR, 'arch_extract_config_file.toml')

            existing_arch_extract = ArchExtract.query.get_or_404(int(archExtractId))

            with open(arch_extract_config_file_path, 'w') as f:
                f.write(existing_arch_extract.archExtractInput)

            cmd = make_arch_extract_command(f'besspin-arch-extract {arch_extract_config_file_path} visualize')
            cp = subprocess.run(
                cmd,
                capture_output=True
            )
            current_app.logger.debug('besspin-arch-extract stdout: ' + str(cp.stdout.decode('utf8')))
            current_app.logger.debug('besspin-arch-extract stderr: ' + str(cp.stderr.decode('utf8')))
            log_output = str(cp.stdout.decode('utf8'))

            out_dir_path = os.path.join('/home/besspinuser/tool-suite', get_variable(existing_arch_extract.archExtractInput, 'out-dir'))
            current_app.logger.debug(f'out_dir_path: {str(out_dir_path)}')

            file_list = os.listdir(out_dir_path)
            current_app.logger.debug(f'file_list: {str(file_list)}')

            file_path_list = []
            for file_item in file_list:
                file_item_path = os.path.join(out_dir_path, file_item)
                current_app.logger.debug(f'file_item_path: {file_item_path}')

                with open(file_item_path, 'r') as f:
                    file_item_text = f.read()
                arch_extract_output_record = ArchExtractOutput(
                    archExtractOutputFilename=file_item_path,
                    archExtractId=int(archExtractId),
                    archExtractOutputContent=file_item_text.encode('utf-8')
                )
                db.session.add(arch_extract_output_record)
                db.session.commit()

                current_app.logger.debug(f'Filename: {str(file_item_path)}')
                current_app.logger.debug(f'OutputId: {str(arch_extract_output_record.archExtractOutputId)}')

                file_path_list += [{
                    'archExtractOutputFilename': file_item_path,
                    'archExtractOutputId': arch_extract_output_record.archExtractOutputId,
                }]

            current_app.logger.debug(f'out: {str(file_path_list)}')
            return { 'archExtractOutputList': file_path_list }
        return

@ns.route('/convert/<string:archExtractOutputId>')
class ArchExtractConvertApi(Resource):
    @ns.marshal_list_with(arch_extract_output_record)
    def get(self, archExtractOutputId):
        current_app.logger.debug(f'convert dot arch extract entry: {archExtractOutputId}')

        existing_arch_extract_output = ArchExtractOutput.query.get_or_404(int(archExtractOutputId))

        if os.environ.get('BESSPIN_CONFIGURATOR_USE_TEMP_DIR'):
            WORK_DIR_OBJ = tempfile.TemporaryDirectory()
            WORK_DIR = WORK_DIR_OBJ.name
        else:
            WORK_DIR = tempfile.gettempdir()

        dotfile_path = os.path.join(WORK_DIR, 'dotfile.dot')
        with open(dotfile_path, 'w') as f:
            f.write(existing_arch_extract_output.archExtractOutputContent.decode())

        dot_to_png = '${f%.dot}.png'
        cmd_png = make_arch_extract_command(f'for f in {WORK_DIR}/*.dot; do dot -Tpng $f -o {dot_to_png}; done')
        current_app.logger.debug(f'command to execute: {cmd_png}')
        cp_png = subprocess.run(
            cmd_png,
            check=True,
            capture_output=True
        )
        current_app.logger.debug('png stdout: ' + str(cp_png.stdout.decode('utf8')))
        current_app.logger.debug('png stderr: ' + str(cp_png.stderr.decode('utf8')))

        with open(os.path.join(WORK_DIR, 'dotfile.png'), 'rb') as f:
            png_bytes = f.read()


        return {
            'archExtractOutputId': int(archExtractOutputId),
            'archExtractOutputFilename': existing_arch_extract_output.archExtractOutputFilename,
            'archExtractOutputContentConverted': base64.b64encode(png_bytes).decode('ascii'),
        }

